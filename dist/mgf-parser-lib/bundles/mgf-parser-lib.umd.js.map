{"version":3,"file":"mgf-parser-lib.umd.js","sources":["../../../projects/mgf-parser-lib/src/lib/mgf-parser-lib.service.ts","../../../projects/mgf-parser-lib/src/lib/mgf-parser-lib.module.ts","../../../projects/mgf-parser-lib/src/public-api.ts","../../../projects/mgf-parser-lib/src/mgf-parser-lib.ts"],"sourcesContent":["import { Injectable, Inject } from '@angular/core';\nimport {NGXLogger} from \"ngx-logger\";\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MgfParserLibService {\n\n  constructor(@Inject(NGXLogger) private logger: NGXLogger) { }\n\n  /**\n   * parses the name field content and modifies the spectra object accordingly\n   * @param value\n   * @param spectraObject\n   * @returns {*}\n   */\n  handleName = (value, spectra) => {\n\n    //check if we have a Retention Index in the name field\n    const nameMatch = /(.+)_RI(.*)/.exec(value);\n    const nameCombinedWithInstruments = /\\s*([:\\w\\d\\s-]+);/.exec(value);\n\n    if (nameMatch) {\n      //sets the new name\n      spectra.names.push(this.trim(nameMatch[1]));\n\n      //adds it as retention index\n      spectra.meta.push(\n        {name: 'Retention Index', value: this.trim(nameMatch[2]), category: this.findCategory('Retention Index')}\n      )\n    } else if (nameCombinedWithInstruments) {\n      spectra.names.push(this.trim(nameCombinedWithInstruments[1]));\n    } else {\n      spectra.name = this.trim(value);\n    }\n\n    return spectra\n  }\n\n  /**\n   * handles a given metadata field and might does additional modifcations\n   * @param value\n   * @param spectra\n   * @param regex regular expression, must provide 2 groups!\n   * @param category\n   * @returns {*}\n   */\n  handleMetaDataField = (value, spectra, regex, category) => {\n    if (!category) {\n      category = \"none\"\n    }\n\n    const extractValue = regex;\n    let match = extractValue.exec(value);\n\n    while (match != null) {\n      const name = this.trim(match[1]);\n      const parsedValue = this.trim(match[2]);\n\n      if (this.ignoreField(name, parsedValue) == false) {\n        spectra.meta.push(\n          {\n            name: name, value: parsedValue, category: category\n          }\n        );\n      }\n      match = extractValue.exec(value);\n    }\n    return spectra;\n  }\n\n  /**\n   * simple trimming function\n   */\n  trim = (str) => {\n    return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '').replace(/^\"(.*)\"$/, '$1');\n  }\n\n  /**\n   * inspects our metadata fields and does additional modifications, as required\n   * @param match\n   * @param spectra\n   *\n   *\n   * @returns {*}\n   */\n  inspectFields = (match, spectra) => {\n    const regexInchIKey = /.*([A-Z]{14}-[A-Z]{10}-[A-Z,0-9])+.*/;\n    //var regexSmiles = /^([^J][0-9BCOHNSOPrIFla@+\\-\\[\\]\\(\\)\\\\\\/%=#$,.~&!]{6,})$/;\n    const regexSmiles = /^([^J][0-9A-Za-z@+\\-\\[\\]\\(\\)\\\\\\/%=#$,.~&!]{6,})$/;\n\n    //if we contain an inchi key in any propterty of this field\n    if (regexInchIKey.exec(match[2])) {\n      spectra.inchiKey = regexInchIKey.exec(match[2])[1];\n    }\n\n    //get an inchi\n    else if (match[1].toLowerCase() == 'inchi' || match[1].toLowerCase() == 'inchicode' || match[1].toLowerCase() == 'inchi code') {\n      spectra.inchi = this.trim(match[2]);\n    }\n\n    //get an inchi from a smile\n    else if (match[1].toLowerCase() == 'smiles' && regexSmiles.exec(match[2])) {\n      spectra.smiles = regexSmiles.exec(match[2])[1];\n    }\n\n    //comment fields have quite often additional infomation in them\n    else if (match[1].toLowerCase() === 'comment') {\n      spectra = this.handleMetaDataField(match[2], spectra, /(\\w+)\\s*=\\s*([0-9]*\\.?[0-9]+)/g, undefined);\n    }\n\n    //can contain a lot of different id's in case of massbank generated msp files\n    else if (match[1].toLowerCase() === 'searchid') {\n      spectra = this.handleMetaDataField(match[2], spectra, /(\\w+\\s?\\w*)+:\\s*([\\w\\d]+[ \\w\\d-]+)/g, \"Database Identifier\");\n    }\n    //this mass bank special flag provides some derivatization information\n    else if (match[1].toLowerCase() === 'ms$focused_ion') {\n      spectra = this.handleMetaDataField(match[2], spectra, /\\s*(.+):(.+)/g, \"Derivatization\");\n    }\n    //any other metadata field\n    else {\n      const name = match[1];\n      const value = match[2];\n\n      if (this.ignoreField(name, value) == false) {\n        //assign metadata\n        spectra.meta.push(\n          {\n            name: name,\n            value: value,\n            category: this.findCategory(name)\n          }\n        );\n      }\n    }\n\n    return spectra;\n  }\n\n  /**\n   * finds the related category for the given name, Will be an additional module at a later point TODO\n   * @param name\n   */\n  findCategory = (name) => {\n    name = name.toLocaleLowerCase();\n\n    let category = \"none\";\n\n    //masspectral properties\n    if (name === '') {\n\n    }\n\n    else if (name === 'retentionindex' || name === 'retention index' ||\n      name === 'retentiontime' || name === 'retention time') {\n      category = \"spectral properties\";\n    }\n\n    //aquisition properties\n    else if (name === 'instrument' || name === 'instrumenttype' || name == 'ionmode' || name == 'precursormz') {\n      category = \"acquisition properties\";\n    }\n\n    return category\n  }\n\n  /**\n   * ignores a given field, if a certain value is not as exspected. Will be an additional module at a later point TODO\n   * @param name\n   * @param value\n   * @returns {boolean}\n   */\n  ignoreField = (name, value) => {\n\n    if (this.trim(name) == '' || this.trim(value) == '') {\n      return true;\n    }\n\n    name = name.toLowerCase();\n\n    if (name == \"retentiontime\" && value <= 0) {\n      return true;\n    }\n    else if (name == \"retentionindex\" && value <= 0) {\n      return true;\n    }\n    //if 0, it doesn't count\n    else if ((name === \"precursormz\" || name === \"derivative_mass\" || name === 'parent') && value <= 0) {\n      return true;\n    }\n    //we get this over the inchi key\n    else if (name == \"formula\") {\n      return true;\n    }\n    else if (name == \"synon\") {\n      return true;\n    }\n    else if (name == \"id\") {\n      return true\n    }\n\n    return false;\n  }\n\n  /**\n   * converts the data using a callback\n   * @param data\n   * @param callback\n   */\n  convertWithCallback = (data, callback) => {\n\n    this.logger.debug(\"starting with parsing new data set...\");\n\n    /**\n     * checks for a complete block of mgf data.\n     * @type {RegExp}\n     */\n    const blockRegEx = /BEGIN IONS([\\s\\S]*?)END IONS/g;\n\n    /**\n     * extracts the attributes like 'name' and 'value' from a found line\n     * @type {RegExp}\n     */\n    const regExAttributes = /\\s*([^=\\s]+)=(.*)\\s/g;\n\n    /**\n     * first block captures meta data\n     * second block caputures spectra including floats\n     * optional third block are identifications of this ion\n     * @type {RegExp}\n     */\n    const regExSpectra = /^((?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)[ \\t]((?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)[ \\t]*(.+)?$/gm;\n\n    /**\n     * is this an accurate mass\n     * @type {RegExp}\n     */\n    const regExAccurateMass = /(\\d*\\.?\\d{3,})/;\n\n    const buf = data.toString('utf8');\n\n    let block, match;\n\n    //go over all available blocks\n    while ((block = blockRegEx.exec(buf)) != null) {\n      block = block[1];\n\n      //contains the resulting spectrum object\n      let spectrum = {meta: [], names: [], name: '', spectrum: '', accurate: false};\n\n      //parse attributes and metadata\n      while ((match = regExAttributes.exec(block)) != null) {\n        if (match[1].toLowerCase() === 'name') {\n          //in case there are RI encoded we extract this information\n          spectrum = this.handleName(match[2], spectrum);\n        } else {\n          spectrum = this.inspectFields(match, spectrum);\n        }\n      }\n\n\n      //builds the actual spectrum\n      spectrum.accurate = true;\n      let ions = [];\n\n      while ((match = regExSpectra.exec(block)) != null) {\n        // Convert scientific notation\n        if (match[1].toLowerCase().indexOf('e') > -1) {\n          match[1] = parseFloat(match[1]).toString();\n        }\n        if (match[2].toLowerCase().indexOf('e') > -1) {\n          match[2] = parseFloat(match[2]).toString();\n        }\n\n        ions.push(match[1] + \":\" + match[2]);\n\n        //used to determine if this is an accurate mass spectrum or not\n        if (!regExAccurateMass.test(match[1])) {\n          spectrum.accurate = false;\n        }\n\n        //add annotation to metadata if defined\n        if (match[3]) {\n          spectrum.meta.push({name: this.trim(match[3]), value: match[1], category: 'annotation'});\n        }\n      }\n\n      //join ions to create spectrum string\n      spectrum.spectrum = ions.join(' ');\n\n\n      //make sure we have at least a spectrum and a name\n      if (spectrum.spectrum != '') {\n        callback(spectrum);\n      } else {\n        this.logger.warn('invalid spectrum found -> ignored');\n      }\n    }\n  };\n\n  convertFromData =  (data, callback) => {\n    return this.convertWithCallback(data, callback);\n  };\n\n  /**\n   * counts the number of mass spectra in this library file\n   * @param data\n   * @returns {number}\n   */\n  countSpectra = (data) => {\n    let count = 0;\n    let pos = data.indexOf('BEGIN IONS', 0);\n\n    while (pos != -1) {\n      count++;\n      pos = data.indexOf('BEGIN IONS', pos + 1);\n    }\n\n    return count;\n  };\n}\n","import { NgModule } from '@angular/core';\nimport { MgfParserLibService } from \"./mgf-parser-lib.service\";\nimport {LoggerModule, NgxLoggerLevel} from \"ngx-logger\";\n\n@NgModule({\n  imports: [\n    LoggerModule.forRoot({\n      level: NgxLoggerLevel.DEBUG,\n      serverLogLevel: NgxLoggerLevel.OFF\n    })\n  ],\n  providers: [\n    MgfParserLibService\n  ]\n})\nexport class MgfParserLibModule { }\n","/*\n * Public API Surface of mgf-parser-lib\n */\n\nexport * from './lib/mgf-parser-lib.service';\nexport * from './lib/mgf-parser-lib.module';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":["NGXLogger","Injectable","Inject","LoggerModule","NgxLoggerLevel","NgModule"],"mappings":"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"}