{"version":3,"sources":["../../../projects/mgf-parser-lib/src/lib/mgf-parser-lib.service.ts","../../../projects/mgf-parser-lib/src/lib/mgf-parser-lib.module.ts"],"names":["logger","_this","this","handleName","value","spectra","nameMatch","exec","nameCombinedWithInstruments","names","push","trim","meta","name","category","findCategory","handleMetaDataField","regex","extractValue","match","parsedValue","ignoreField","str","replace","inspectFields","regexInchIKey","regexSmiles","inchiKey","toLowerCase","inchi","smiles","undefined","toLocaleLowerCase","convertWithCallback","data","callback","debug","block","blockRegEx","regExAttributes","regExSpectra","regExAccurateMass","buf","toString","spectrum","accurate","ions","indexOf","parseFloat","test","join","warn","convertFromData","countSpectra","count","pos","MgfParserLibService","i0","ɵɵinject","NGXLogger","factory","ɵfac","providedIn","MgfParserLibModule","providers","imports","LoggerModule","forRoot","level","NgxLoggerLevel","DEBUG","serverLogLevel","OFF","i1"],"mappings":"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","sourcesContent":["import { Injectable, Inject } from '@angular/core';\nimport {NGXLogger} from \"ngx-logger\";\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MgfParserLibService {\n\n  constructor(@Inject(NGXLogger) private logger: NGXLogger) { }\n\n  /**\n   * parses the name field content and modifies the spectra object accordingly\n   * @param value\n   * @param spectraObject\n   * @returns {*}\n   */\n  handleName = (value, spectra) => {\n\n    //check if we have a Retention Index in the name field\n    const nameMatch = /(.+)_RI(.*)/.exec(value);\n    const nameCombinedWithInstruments = /\\s*([:\\w\\d\\s-]+);/.exec(value);\n\n    if (nameMatch) {\n      //sets the new name\n      spectra.names.push(this.trim(nameMatch[1]));\n\n      //adds it as retention index\n      spectra.meta.push(\n        {name: 'Retention Index', value: this.trim(nameMatch[2]), category: this.findCategory('Retention Index')}\n      )\n    } else if (nameCombinedWithInstruments) {\n      spectra.names.push(this.trim(nameCombinedWithInstruments[1]));\n    } else {\n      spectra.name = this.trim(value);\n    }\n\n    return spectra\n  }\n\n  /**\n   * handles a given metadata field and might does additional modifcations\n   * @param value\n   * @param spectra\n   * @param regex regular expression, must provide 2 groups!\n   * @param category\n   * @returns {*}\n   */\n  handleMetaDataField = (value, spectra, regex, category) => {\n    if (!category) {\n      category = \"none\"\n    }\n\n    const extractValue = regex;\n    let match = extractValue.exec(value);\n\n    while (match != null) {\n      const name = this.trim(match[1]);\n      const parsedValue = this.trim(match[2]);\n\n      if (this.ignoreField(name, parsedValue) == false) {\n        spectra.meta.push(\n          {\n            name: name, value: parsedValue, category: category\n          }\n        );\n      }\n      match = extractValue.exec(value);\n    }\n    return spectra;\n  }\n\n  /**\n   * simple trimming function\n   */\n  trim = (str) => {\n    return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '').replace(/^\"(.*)\"$/, '$1');\n  }\n\n  /**\n   * inspects our metadata fields and does additional modifications, as required\n   * @param match\n   * @param spectra\n   *\n   *\n   * @returns {*}\n   */\n  inspectFields = (match, spectra) => {\n    const regexInchIKey = /.*([A-Z]{14}-[A-Z]{10}-[A-Z,0-9])+.*/;\n    //var regexSmiles = /^([^J][0-9BCOHNSOPrIFla@+\\-\\[\\]\\(\\)\\\\\\/%=#$,.~&!]{6,})$/;\n    const regexSmiles = /^([^J][0-9A-Za-z@+\\-\\[\\]\\(\\)\\\\\\/%=#$,.~&!]{6,})$/;\n\n    //if we contain an inchi key in any propterty of this field\n    if (regexInchIKey.exec(match[2])) {\n      spectra.inchiKey = regexInchIKey.exec(match[2])[1];\n    }\n\n    //get an inchi\n    else if (match[1].toLowerCase() == 'inchi' || match[1].toLowerCase() == 'inchicode' || match[1].toLowerCase() == 'inchi code') {\n      spectra.inchi = this.trim(match[2]);\n    }\n\n    //get an inchi from a smile\n    else if (match[1].toLowerCase() == 'smiles' && regexSmiles.exec(match[2])) {\n      spectra.smiles = regexSmiles.exec(match[2])[1];\n    }\n\n    //comment fields have quite often additional infomation in them\n    else if (match[1].toLowerCase() === 'comment') {\n      spectra = this.handleMetaDataField(match[2], spectra, /(\\w+)\\s*=\\s*([0-9]*\\.?[0-9]+)/g, undefined);\n    }\n\n    //can contain a lot of different id's in case of massbank generated msp files\n    else if (match[1].toLowerCase() === 'searchid') {\n      spectra = this.handleMetaDataField(match[2], spectra, /(\\w+\\s?\\w*)+:\\s*([\\w\\d]+[ \\w\\d-]+)/g, \"Database Identifier\");\n    }\n    //this mass bank special flag provides some derivatization information\n    else if (match[1].toLowerCase() === 'ms$focused_ion') {\n      spectra = this.handleMetaDataField(match[2], spectra, /\\s*(.+):(.+)/g, \"Derivatization\");\n    }\n    //any other metadata field\n    else {\n      const name = match[1];\n      const value = match[2];\n\n      if (this.ignoreField(name, value) == false) {\n        //assign metadata\n        spectra.meta.push(\n          {\n            name: name,\n            value: value,\n            category: this.findCategory(name)\n          }\n        );\n      }\n    }\n\n    return spectra;\n  }\n\n  /**\n   * finds the related category for the given name, Will be an additional module at a later point TODO\n   * @param name\n   */\n  findCategory = (name) => {\n    name = name.toLocaleLowerCase();\n\n    let category = \"none\";\n\n    //masspectral properties\n    if (name === '') {\n\n    }\n\n    else if (name === 'retentionindex' || name === 'retention index' ||\n      name === 'retentiontime' || name === 'retention time') {\n      category = \"spectral properties\";\n    }\n\n    //aquisition properties\n    else if (name === 'instrument' || name === 'instrumenttype' || name == 'ionmode' || name == 'precursormz') {\n      category = \"acquisition properties\";\n    }\n\n    return category\n  }\n\n  /**\n   * ignores a given field, if a certain value is not as exspected. Will be an additional module at a later point TODO\n   * @param name\n   * @param value\n   * @returns {boolean}\n   */\n  ignoreField = (name, value) => {\n\n    if (this.trim(name) == '' || this.trim(value) == '') {\n      return true;\n    }\n\n    name = name.toLowerCase();\n\n    if (name == \"retentiontime\" && value <= 0) {\n      return true;\n    }\n    else if (name == \"retentionindex\" && value <= 0) {\n      return true;\n    }\n    //if 0, it doesn't count\n    else if ((name === \"precursormz\" || name === \"derivative_mass\" || name === 'parent') && value <= 0) {\n      return true;\n    }\n    //we get this over the inchi key\n    else if (name == \"formula\") {\n      return true;\n    }\n    else if (name == \"synon\") {\n      return true;\n    }\n    else if (name == \"id\") {\n      return true\n    }\n\n    return false;\n  }\n\n  /**\n   * converts the data using a callback\n   * @param data\n   * @param callback\n   */\n  convertWithCallback = (data, callback) => {\n\n    this.logger.debug(\"starting with parsing new data set...\");\n\n    /**\n     * checks for a complete block of mgf data.\n     * @type {RegExp}\n     */\n    const blockRegEx = /BEGIN IONS([\\s\\S]*?)END IONS/g;\n\n    /**\n     * extracts the attributes like 'name' and 'value' from a found line\n     * @type {RegExp}\n     */\n    const regExAttributes = /\\s*([^=\\s]+)=(.*)\\s/g;\n\n    /**\n     * first block captures meta data\n     * second block caputures spectra including floats\n     * optional third block are identifications of this ion\n     * @type {RegExp}\n     */\n    const regExSpectra = /^((?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)[ \\t]((?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)[ \\t]*(.+)?$/gm;\n\n    /**\n     * is this an accurate mass\n     * @type {RegExp}\n     */\n    const regExAccurateMass = /(\\d*\\.?\\d{3,})/;\n\n    const buf = data.toString('utf8');\n\n    let block, match;\n\n    //go over all available blocks\n    while ((block = blockRegEx.exec(buf)) != null) {\n      block = block[1];\n\n      //contains the resulting spectrum object\n      let spectrum = {meta: [], names: [], name: '', spectrum: '', accurate: false};\n\n      //parse attributes and metadata\n      while ((match = regExAttributes.exec(block)) != null) {\n        if (match[1].toLowerCase() === 'name') {\n          //in case there are RI encoded we extract this information\n          spectrum = this.handleName(match[2], spectrum);\n        } else {\n          spectrum = this.inspectFields(match, spectrum);\n        }\n      }\n\n\n      //builds the actual spectrum\n      spectrum.accurate = true;\n      let ions = [];\n\n      while ((match = regExSpectra.exec(block)) != null) {\n        // Convert scientific notation\n        if (match[1].toLowerCase().indexOf('e') > -1) {\n          match[1] = parseFloat(match[1]).toString();\n        }\n        if (match[2].toLowerCase().indexOf('e') > -1) {\n          match[2] = parseFloat(match[2]).toString();\n        }\n\n        ions.push(match[1] + \":\" + match[2]);\n\n        //used to determine if this is an accurate mass spectrum or not\n        if (!regExAccurateMass.test(match[1])) {\n          spectrum.accurate = false;\n        }\n\n        //add annotation to metadata if defined\n        if (match[3]) {\n          spectrum.meta.push({name: this.trim(match[3]), value: match[1], category: 'annotation'});\n        }\n      }\n\n      //join ions to create spectrum string\n      spectrum.spectrum = ions.join(' ');\n\n\n      //make sure we have at least a spectrum and a name\n      if (spectrum.spectrum != '') {\n        callback(spectrum);\n      } else {\n        this.logger.warn('invalid spectrum found -> ignored');\n      }\n    }\n  };\n\n  convertFromData =  (data, callback) => {\n    return this.convertWithCallback(data, callback);\n  };\n\n  /**\n   * counts the number of mass spectra in this library file\n   * @param data\n   * @returns {number}\n   */\n  countSpectra = (data) => {\n    let count = 0;\n    let pos = data.indexOf('BEGIN IONS', 0);\n\n    while (pos != -1) {\n      count++;\n      pos = data.indexOf('BEGIN IONS', pos + 1);\n    }\n\n    return count;\n  };\n}\n","import { NgModule } from '@angular/core';\nimport { MgfParserLibService } from \"./mgf-parser-lib.service\";\nimport {LoggerModule, NgxLoggerLevel} from \"ngx-logger\";\n\n@NgModule({\n  imports: [\n    LoggerModule.forRoot({\n      level: NgxLoggerLevel.DEBUG,\n      serverLogLevel: NgxLoggerLevel.OFF\n    })\n  ],\n  providers: [\n    MgfParserLibService\n  ]\n})\nexport class MgfParserLibModule { }\n"]}