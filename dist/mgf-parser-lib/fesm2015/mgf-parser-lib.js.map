{"version":3,"file":"mgf-parser-lib.js","sources":["../../../projects/mgf-parser-lib/src/lib/mgf-parser-lib.service.ts","../../../projects/mgf-parser-lib/src/lib/mgf-parser-lib.module.ts","../../../projects/mgf-parser-lib/src/public-api.ts","../../../projects/mgf-parser-lib/src/mgf-parser-lib.ts"],"sourcesContent":["import { Injectable, Inject } from '@angular/core';\nimport {NGXLogger} from \"ngx-logger\";\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MgfParserLibService {\n\n  constructor(@Inject(NGXLogger) private logger: NGXLogger) { }\n\n  /**\n   * parses the name field content and modifies the spectra object accordingly\n   * @param value\n   * @param spectraObject\n   * @returns {*}\n   */\n  handleName = (value, spectra) => {\n\n    //check if we have a Retention Index in the name field\n    const nameMatch = /(.+)_RI(.*)/.exec(value);\n    const nameCombinedWithInstruments = /\\s*([:\\w\\d\\s-]+);/.exec(value);\n\n    if (nameMatch) {\n      //sets the new name\n      spectra.names.push(this.trim(nameMatch[1]));\n\n      //adds it as retention index\n      spectra.meta.push(\n        {name: 'Retention Index', value: this.trim(nameMatch[2]), category: this.findCategory('Retention Index')}\n      )\n    } else if (nameCombinedWithInstruments) {\n      spectra.names.push(this.trim(nameCombinedWithInstruments[1]));\n    } else {\n      spectra.name = this.trim(value);\n    }\n\n    return spectra\n  }\n\n  /**\n   * handles a given metadata field and might does additional modifcations\n   * @param value\n   * @param spectra\n   * @param regex regular expression, must provide 2 groups!\n   * @param category\n   * @returns {*}\n   */\n  handleMetaDataField = (value, spectra, regex, category) => {\n    if (!category) {\n      category = \"none\"\n    }\n\n    const extractValue = regex;\n    let match = extractValue.exec(value);\n\n    while (match != null) {\n      const name = this.trim(match[1]);\n      const parsedValue = this.trim(match[2]);\n\n      if (this.ignoreField(name, parsedValue) == false) {\n        spectra.meta.push(\n          {\n            name: name, value: parsedValue, category: category\n          }\n        );\n      }\n      match = extractValue.exec(value);\n    }\n    return spectra;\n  }\n\n  /**\n   * simple trimming function\n   */\n  trim = (str) => {\n    return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '').replace(/^\"(.*)\"$/, '$1');\n  }\n\n  /**\n   * inspects our metadata fields and does additional modifications, as required\n   * @param match\n   * @param spectra\n   *\n   *\n   * @returns {*}\n   */\n  inspectFields = (match, spectra) => {\n    const regexInchIKey = /.*([A-Z]{14}-[A-Z]{10}-[A-Z,0-9])+.*/;\n    //var regexSmiles = /^([^J][0-9BCOHNSOPrIFla@+\\-\\[\\]\\(\\)\\\\\\/%=#$,.~&!]{6,})$/;\n    const regexSmiles = /^([^J][0-9A-Za-z@+\\-\\[\\]\\(\\)\\\\\\/%=#$,.~&!]{6,})$/;\n\n    //if we contain an inchi key in any propterty of this field\n    if (regexInchIKey.exec(match[2])) {\n      spectra.inchiKey = regexInchIKey.exec(match[2])[1];\n    }\n\n    //get an inchi\n    else if (match[1].toLowerCase() == 'inchi' || match[1].toLowerCase() == 'inchicode' || match[1].toLowerCase() == 'inchi code') {\n      spectra.inchi = this.trim(match[2]);\n    }\n\n    //get an inchi from a smile\n    else if (match[1].toLowerCase() == 'smiles' && regexSmiles.exec(match[2])) {\n      spectra.smiles = regexSmiles.exec(match[2])[1];\n    }\n\n    //comment fields have quite often additional infomation in them\n    else if (match[1].toLowerCase() === 'comment') {\n      spectra = this.handleMetaDataField(match[2], spectra, /(\\w+)\\s*=\\s*([0-9]*\\.?[0-9]+)/g, undefined);\n    }\n\n    //can contain a lot of different id's in case of massbank generated msp files\n    else if (match[1].toLowerCase() === 'searchid') {\n      spectra = this.handleMetaDataField(match[2], spectra, /(\\w+\\s?\\w*)+:\\s*([\\w\\d]+[ \\w\\d-]+)/g, \"Database Identifier\");\n    }\n    //this mass bank special flag provides some derivatization information\n    else if (match[1].toLowerCase() === 'ms$focused_ion') {\n      spectra = this.handleMetaDataField(match[2], spectra, /\\s*(.+):(.+)/g, \"Derivatization\");\n    }\n    //any other metadata field\n    else {\n      const name = match[1];\n      const value = match[2];\n\n      if (this.ignoreField(name, value) == false) {\n        //assign metadata\n        spectra.meta.push(\n          {\n            name: name,\n            value: value,\n            category: this.findCategory(name)\n          }\n        );\n      }\n    }\n\n    return spectra;\n  }\n\n  /**\n   * finds the related category for the given name, Will be an additional module at a later point TODO\n   * @param name\n   */\n  findCategory = (name) => {\n    name = name.toLocaleLowerCase();\n\n    let category = \"none\";\n\n    //masspectral properties\n    if (name === '') {\n\n    }\n\n    else if (name === 'retentionindex' || name === 'retention index' ||\n      name === 'retentiontime' || name === 'retention time') {\n      category = \"spectral properties\";\n    }\n\n    //aquisition properties\n    else if (name === 'instrument' || name === 'instrumenttype' || name == 'ionmode' || name == 'precursormz') {\n      category = \"acquisition properties\";\n    }\n\n    return category\n  }\n\n  /**\n   * ignores a given field, if a certain value is not as exspected. Will be an additional module at a later point TODO\n   * @param name\n   * @param value\n   * @returns {boolean}\n   */\n  ignoreField = (name, value) => {\n\n    if (this.trim(name) == '' || this.trim(value) == '') {\n      return true;\n    }\n\n    name = name.toLowerCase();\n\n    if (name == \"retentiontime\" && value <= 0) {\n      return true;\n    }\n    else if (name == \"retentionindex\" && value <= 0) {\n      return true;\n    }\n    //if 0, it doesn't count\n    else if ((name === \"precursormz\" || name === \"derivative_mass\" || name === 'parent') && value <= 0) {\n      return true;\n    }\n    //we get this over the inchi key\n    else if (name == \"formula\") {\n      return true;\n    }\n    else if (name == \"synon\") {\n      return true;\n    }\n    else if (name == \"id\") {\n      return true\n    }\n\n    return false;\n  }\n\n  /**\n   * converts the data using a callback\n   * @param data\n   * @param callback\n   */\n  convertWithCallback = (data, callback) => {\n\n    this.logger.debug(\"starting with parsing new data set...\");\n\n    /**\n     * checks for a complete block of mgf data.\n     * @type {RegExp}\n     */\n    const blockRegEx = /BEGIN IONS([\\s\\S]*?)END IONS/g;\n\n    /**\n     * extracts the attributes like 'name' and 'value' from a found line\n     * @type {RegExp}\n     */\n    const regExAttributes = /\\s*([^=\\s]+)=(.*)\\s/g;\n\n    /**\n     * first block captures meta data\n     * second block caputures spectra including floats\n     * optional third block are identifications of this ion\n     * @type {RegExp}\n     */\n    const regExSpectra = /^((?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)[ \\t]((?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)[ \\t]*(.+)?$/gm;\n\n    /**\n     * is this an accurate mass\n     * @type {RegExp}\n     */\n    const regExAccurateMass = /(\\d*\\.?\\d{3,})/;\n\n    const buf = data.toString('utf8');\n\n    let block, match;\n\n    //go over all available blocks\n    while ((block = blockRegEx.exec(buf)) != null) {\n      block = block[1];\n\n      //contains the resulting spectrum object\n      let spectrum = {meta: [], names: [], name: '', spectrum: '', accurate: false};\n\n      //parse attributes and metadata\n      while ((match = regExAttributes.exec(block)) != null) {\n        if (match[1].toLowerCase() === 'name') {\n          //in case there are RI encoded we extract this information\n          spectrum = this.handleName(match[2], spectrum);\n        } else {\n          spectrum = this.inspectFields(match, spectrum);\n        }\n      }\n\n\n      //builds the actual spectrum\n      spectrum.accurate = true;\n      let ions = [];\n\n      while ((match = regExSpectra.exec(block)) != null) {\n        // Convert scientific notation\n        if (match[1].toLowerCase().indexOf('e') > -1) {\n          match[1] = parseFloat(match[1]).toString();\n        }\n        if (match[2].toLowerCase().indexOf('e') > -1) {\n          match[2] = parseFloat(match[2]).toString();\n        }\n\n        ions.push(match[1] + \":\" + match[2]);\n\n        //used to determine if this is an accurate mass spectrum or not\n        if (!regExAccurateMass.test(match[1])) {\n          spectrum.accurate = false;\n        }\n\n        //add annotation to metadata if defined\n        if (match[3]) {\n          spectrum.meta.push({name: this.trim(match[3]), value: match[1], category: 'annotation'});\n        }\n      }\n\n      //join ions to create spectrum string\n      spectrum.spectrum = ions.join(' ');\n\n\n      //make sure we have at least a spectrum and a name\n      if (spectrum.spectrum != '') {\n        callback(spectrum);\n      } else {\n        this.logger.warn('invalid spectrum found -> ignored');\n      }\n    }\n  };\n\n  convertFromData =  (data, callback) => {\n    return this.convertWithCallback(data, callback);\n  };\n\n  /**\n   * counts the number of mass spectra in this library file\n   * @param data\n   * @returns {number}\n   */\n  countSpectra = (data) => {\n    let count = 0;\n    let pos = data.indexOf('BEGIN IONS', 0);\n\n    while (pos != -1) {\n      count++;\n      pos = data.indexOf('BEGIN IONS', pos + 1);\n    }\n\n    return count;\n  };\n}\n","import { NgModule } from '@angular/core';\nimport { MgfParserLibService } from \"./mgf-parser-lib.service\";\nimport {LoggerModule, NgxLoggerLevel} from \"ngx-logger\";\n\n@NgModule({\n  imports: [\n    LoggerModule.forRoot({\n      level: NgxLoggerLevel.DEBUG,\n      serverLogLevel: NgxLoggerLevel.OFF\n    })\n  ],\n  providers: [\n    MgfParserLibService\n  ]\n})\nexport class MgfParserLibModule { }\n","/*\n * Public API Surface of mgf-parser-lib\n */\n\nexport * from './lib/mgf-parser-lib.service';\nexport * from './lib/mgf-parser-lib.module';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":"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"}